# Plan de Refactorizaci√≥n - FastMCP Nativo

## üéØ Objetivo
Migrar el c√≥digo actual para usar caracter√≠sticas nativas de FastMCP 2.13, reduciendo complejidad y mejorando rendimiento.

---

## üìã Cambio 1: Middleware Nativo (CR√çTICO)

### Archivo: `src/trackhs_mcp/middleware.py`

#### ANTES (Actual - 134 l√≠neas)
```python
class LoggingMiddleware:
    """Middleware de logging para todas las operaciones"""
    def __init__(self):
        self.request_count = 0
        self.error_count = 0

    async def __call__(self, request, next_handler):
        # L√≥gica manual...
```

#### DESPU√âS (Nuevo - ~40 l√≠neas)
```python
"""
Middleware FastMCP-compatible para TrackHS MCP Server
"""
import logging
import time
from typing import Any

from fastmcp.server.middleware import Middleware, MiddlewareContext

logger = logging.getLogger(__name__)


class TrackHSMiddleware(Middleware):
    """
    Middleware unificado para logging, autenticaci√≥n y m√©tricas.
    Compatible con FastMCP 2.9+
    """

    def __init__(self, api_client=None, auth_cache_ttl: int = 300):
        self.api_client = api_client
        self.auth_cache_ttl = auth_cache_ttl
        self.last_auth_check = None
        self.is_authenticated = False

        # M√©tricas
        self.metrics = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
        }
        self.response_times = []

    async def on_message(self, context: MiddlewareContext, call_next):
        """
        Intercepta cada mensaje MCP para aplicar logging, auth y m√©tricas.
        """
        self.metrics["total_requests"] += 1
        start_time = time.time()

        # 1. Verificar autenticaci√≥n (con cache)
        if self.api_client is None:
            from .exceptions import AuthenticationError
            raise AuthenticationError(
                "API client no disponible. Configure TRACKHS_USERNAME y TRACKHS_PASSWORD"
            )

        # Cache de autenticaci√≥n (solo verificar cada 5 minutos)
        now = time.time()
        if (
            self.last_auth_check is None
            or (now - self.last_auth_check) > self.auth_cache_ttl
        ):
            try:
                # Verificaci√≥n ligera
                self.api_client.get("pms/units/amenities", {"page": 1, "size": 1})
                self.is_authenticated = True
                self.last_auth_check = now
                logger.debug("Authentication cache refreshed")
            except Exception as e:
                self.is_authenticated = False
                logger.error(f"Authentication failed: {str(e)}")
                from .exceptions import AuthenticationError
                raise AuthenticationError(f"Credenciales inv√°lidas: {str(e)}")

        if not self.is_authenticated:
            from .exceptions import AuthenticationError
            raise AuthenticationError("No autenticado")

        # 2. Logging de request
        logger.info(
            f"Tool called: {context.method} | "
            f"Request #{self.metrics['total_requests']}"
        )

        # 3. Ejecutar la herramienta
        try:
            result = await call_next(context)

            # 4. M√©tricas de √©xito
            duration = time.time() - start_time
            self.response_times.append(duration)
            self.metrics["successful_requests"] += 1

            avg_time = sum(self.response_times) / len(self.response_times)

            logger.info(
                f"‚úÖ Success | Duration: {duration:.2f}s | "
                f"Avg: {avg_time:.2f}s"
            )

            return result

        except Exception as e:
            # 5. M√©tricas de error
            duration = time.time() - start_time
            self.metrics["failed_requests"] += 1
            error_rate = (
                self.metrics["failed_requests"]
                / self.metrics["total_requests"]
            ) * 100

            logger.error(
                f"‚ùå Error in {context.method} | "
                f"Duration: {duration:.2f}s | "
                f"Error rate: {error_rate:.1f}% | "
                f"Error: {type(e).__name__}: {str(e)}"
            )

            raise

    def get_metrics(self) -> dict[str, Any]:
        """Retorna m√©tricas actuales"""
        avg_time = (
            sum(self.response_times) / len(self.response_times)
            if self.response_times
            else 0
        )

        return {
            **self.metrics,
            "average_response_time": avg_time,
            "error_rate": (
                (self.metrics["failed_requests"] / self.metrics["total_requests"]) * 100
                if self.metrics["total_requests"] > 0
                else 0
            ),
        }
```

---

## üìã Cambio 2: Servidor con Middleware Integrado

### Archivo: `src/trackhs_mcp/server.py`

#### ANTES (l√≠neas 380-430)
```python
# Crear servidor MCP con validaci√≥n estricta
mcp = FastMCP(
    name="TrackHS API",
    instructions="""...""",
    strict_input_validation=True,
)

# Inicializar middleware
logging_middleware = LoggingMiddleware()
auth_middleware = AuthenticationMiddleware(api_client)
metrics_middleware = MetricsMiddleware()

# ‚úÖ Quick Win #1: Habilitar middleware
# Nota: El middleware se aplica a nivel de funci√≥n en cada tool
# FastMCP gestiona el middleware de forma integrada con las herramientas
```

#### DESPU√âS
```python
from contextlib import asynccontextmanager
from fastmcp.server.middleware.error_handling import (
    ErrorHandlingMiddleware,
    RetryMiddleware,
)
from .middleware import TrackHSMiddleware

# Server Lifespan para inicializaci√≥n/limpieza
@asynccontextmanager
async def lifespan(server):
    """
    Maneja el ciclo de vida del servidor MCP.
    Se ejecuta una vez al inicio y al final.
    """
    # Inicializaci√≥n
    logger.info("üöÄ TrackHS MCP Server iniciando...")
    logger.info(f"üìç Base URL: {API_BASE_URL}")

    # Verificar conexi√≥n API
    if api_client:
        try:
            start = time.time()
            api_client.get("pms/units/amenities", {"page": 1, "size": 1})
            duration = time.time() - start
            logger.info(f"‚úÖ API TrackHS conectada ({duration:.2f}s)")
        except Exception as e:
            logger.error(f"‚ùå API TrackHS no disponible: {e}")
            logger.warning("El servidor se iniciar√° pero las herramientas fallar√°n")
    else:
        logger.warning("‚ö†Ô∏è  Credenciales no configuradas")

    logger.info("‚úÖ Servidor listo para recibir requests")

    yield  # Servidor corriendo

    # Limpieza
    logger.info("üõë TrackHS MCP Server cerrando...")
    if api_client and hasattr(api_client, 'client'):
        api_client.client.close()
        logger.info("‚úÖ Conexiones cerradas")

# Crear servidor MCP con todas las mejoras
mcp = FastMCP(
    name="TrackHS API",
    instructions="""Servidor MCP para interactuar con la API de TrackHS.

    Proporciona herramientas para:
    - Buscar y consultar reservas
    - Gestionar unidades de alojamiento
    - Consultar amenidades disponibles
    - Obtener informaci√≥n financiera (folios)
    - Crear √≥rdenes de trabajo (mantenimiento y housekeeping)

    Todas las herramientas incluyen validaci√≥n robusta y documentaci√≥n completa.""",
    strict_input_validation=True,
    mask_error_details=True,  # ‚úÖ Seguridad en producci√≥n
    lifespan=lifespan,  # ‚úÖ Ciclo de vida
)

# ‚úÖ Registrar middleware nativo de FastMCP
mcp.add_middleware(
    ErrorHandlingMiddleware(
        include_traceback=True,
        transform_errors=True,
    )
)

mcp.add_middleware(
    RetryMiddleware(
        max_retries=3,
        retry_exceptions=(httpx.RequestError, httpx.HTTPStatusError),
        backoff_factor=2.0,
    )
)

# ‚úÖ Middleware personalizado unificado
trackhs_middleware = TrackHSMiddleware(
    api_client=api_client,
    auth_cache_ttl=300,  # 5 minutos
)
mcp.add_middleware(trackhs_middleware)

logger.info("‚úÖ Middleware registrado correctamente")
```

---

## üìã Cambio 3: Simplificar Tools (Eliminar C√≥digo Manual)

### Archivo: `src/trackhs_mcp/server.py`

#### ANTES (l√≠neas 432-544 - search_reservations)
```python
@mcp.tool(output_schema=RESERVATION_SEARCH_OUTPUT_SCHEMA)
def search_reservations(
    page: Annotated[int, Field(ge=0, le=10000, ...)] = 0,
    size: Annotated[int, Field(ge=1, le=100, ...)] = 10,
    # ... m√°s par√°metros
) -> Dict[str, Any]:
    """Buscar reservas en TrackHS..."""

    # ‚ùå Aplicar middleware de logging (MANUAL)
    logging_middleware.request_count += 1
    start_time = time.time()

    logger.info(f"Buscando reservas con par√°metros: ...")

    # ‚ùå Aplicar middleware de autenticaci√≥n (MANUAL)
    if api_client is None:
        raise AuthenticationError(...)

    params = {"page": page, "size": size}
    # ... construir params

    try:
        result = api_client.get("pms/reservations", params)

        # ‚ùå Aplicar middleware de m√©tricas (MANUAL)
        duration = time.time() - start_time
        metrics_middleware.metrics["successful_requests"] += 1
        metrics_middleware.response_times.append(duration)
        metrics_middleware.metrics["average_response_time"] = ...

        logger.info(f"B√∫squeda de reservas exitosa - ...")
        return result

    except Exception as e:
        # ‚ùå Aplicar middleware de m√©tricas para errores (MANUAL)
        metrics_middleware.metrics["failed_requests"] += 1
        metrics_middleware.metrics["error_rate"] = ...

        logger.error(f"Error en b√∫squeda de reservas: {str(e)}")
        raise
```

#### DESPU√âS (Simplificado - ~30 l√≠neas menos)
```python
@mcp.tool(output_schema=RESERVATION_SEARCH_OUTPUT_SCHEMA)
def search_reservations(
    page: Annotated[int, Field(ge=0, le=10000, ...)] = 0,
    size: Annotated[int, Field(ge=1, le=100, ...)] = 10,
    search: Annotated[Optional[str], Field(...)] = None,
    arrival_start: Annotated[Optional[str], Field(...)] = None,
    arrival_end: Annotated[Optional[str], Field(...)] = None,
    status: Annotated[Optional[str], Field(...)] = None,
) -> Dict[str, Any]:
    """
    Buscar reservas en TrackHS con filtros avanzados.

    [Documentaci√≥n completa igual que antes]
    """
    # ‚úÖ Sin c√≥digo de middleware - se aplica autom√°ticamente

    # Construir par√°metros de b√∫squeda
    params = {"page": page, "size": size}
    if search:
        params["search"] = search
    if arrival_start:
        params["arrival_start"] = arrival_start
    if arrival_end:
        params["arrival_end"] = arrival_end
    if status:
        params["status"] = status

    # Llamar a la API (con reintentos autom√°ticos del middleware)
    result = api_client.get("pms/reservations", params)

    return result  # ‚úÖ Simple y limpio
```

**Resultado:**
- ‚ùå Eliminadas ~25 l√≠neas de c√≥digo repetitivo
- ‚úÖ M√°s f√°cil de leer y mantener
- ‚úÖ Middleware se aplica autom√°ticamente
- ‚úÖ Logging, autenticaci√≥n, m√©tricas y reintentos sin c√≥digo manual

---

## üìã Cambio 4: Eliminar retry_with_backoff (Ya Incluido en Middleware)

### Archivo: `src/trackhs_mcp/server.py`

#### ANTES (l√≠neas 147-206)
```python
def retry_with_backoff(
    func, max_retries: int = MAX_RETRIES, base_delay: float = RETRY_DELAY_BASE
):
    """Ejecuta una funci√≥n con reintentos autom√°ticos..."""
    # ... ~60 l√≠neas de c√≥digo de reintentos
```

#### DESPU√âS
```python
# ‚ùå ELIMINAR COMPLETAMENTE - Ya no se necesita
# FastMCP RetryMiddleware maneja esto autom√°ticamente
```

### Archivo: `src/trackhs_mcp/server.py` - TrackHSClient

#### ANTES (l√≠neas 245-314 en m√©todo `get()`)
```python
def get(self, endpoint: str, params: Optional[Dict] = None) -> Dict[str, Any]:
    """GET request to TrackHS API"""
    # ...
    def _execute_request():
        # ... l√≥gica de request

    # ‚ùå Ejecutar con reintentos autom√°ticos
    return retry_with_backoff(_execute_request)
```

#### DESPU√âS (Simplificado)
```python
def get(self, endpoint: str, params: Optional[Dict] = None) -> Dict[str, Any]:
    """GET request to TrackHS API with error handling"""
    full_url = f"{self.base_url}/{endpoint}"
    sanitized_params = sanitize_for_log(params)
    logger.info(f"GET request to {full_url} with params: {sanitized_params}")

    # ‚úÖ Request directo - RetryMiddleware maneja reintentos
    try:
        response = self.client.get(full_url, params=params)
        logger.info(f"Response status: {response.status_code}")

        response.raise_for_status()

        response_data = response.json()
        sanitized_response = sanitize_for_log(response_data)
        logger.info(f"Response preview: {str(sanitized_response)[:500]}")

        return response_data

    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP Error {e.response.status_code}")

        if "text/html" in e.response.headers.get("content-type", ""):
            raise NotFoundError(
                f"Endpoint no encontrado. URL: {full_url}"
            )

        if e.response.status_code == 401:
            raise AuthenticationError(f"Credenciales inv√°lidas: {e.response.text}")
        elif e.response.status_code == 403:
            raise AuthenticationError(f"Acceso denegado: {e.response.text}")
        elif e.response.status_code == 404:
            raise NotFoundError(f"Recurso no encontrado: {e.response.text}")
        elif e.response.status_code == 422:
            raise ValidationError(f"Error de validaci√≥n: {e.response.text}")
        else:
            raise APIError(f"Error de API: {e.response.status_code} - {e.response.text}")

    except httpx.RequestError as e:
        # RetryMiddleware manejar√° reintentos de errores de red
        raise ConnectionError(f"Error de conexi√≥n con TrackHS: {str(e)}")

    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        raise TrackHSError(f"Error inesperado: {str(e)}")
```

**Resultado:**
- ‚ùå Eliminadas ~60 l√≠neas de `retry_with_backoff()`
- ‚ùå Eliminadas ~30 l√≠neas de wrapping en `get()` y `post()`
- ‚úÖ C√≥digo m√°s simple y directo
- ‚úÖ Reintentos manejados por FastMCP RetryMiddleware

---

## üìã Cambio 5: Response Caching para Amenidades

### Archivo: `src/trackhs_mcp/server.py`

```python
# Despu√©s de registrar el middleware principal, agregar caching

# ‚úÖ NUEVO: Cache para consultas que raramente cambian
# Nota: Requiere instalar fastmcp[cache] o implementaci√≥n personalizada
try:
    from fastmcp.server.middleware.caching import ResponseCachingMiddleware

    mcp.add_middleware(
        ResponseCachingMiddleware(
            ttl=3600,  # 1 hora
            cache_tools=["search_amenities"],  # Solo cachear amenidades
        )
    )
    logger.info("‚úÖ Response caching habilitado para amenidades")
except ImportError:
    logger.warning("‚ö†Ô∏è  ResponseCachingMiddleware no disponible")
    # Continuar sin caching
```

---

## üìã Cambio 6: Health Check Mejorado

### Archivo: `src/trackhs_mcp/server.py`

#### ANTES (l√≠neas 1010-1061)
```python
@mcp.resource("https://trackhs-mcp.local/health")
def health_check():
    """Health check endpoint"""
    # ... c√≥digo con version hardcoded
    "fastmcp_version": "2.12.5",  # ‚ö†Ô∏è Desactualizado
```

#### DESPU√âS
```python
import fastmcp
import json

@mcp.resource("https://trackhs-mcp.local/health")
def health_check() -> str:
    """
    Health check endpoint para monitoreo del servidor.

    Retorna estado del servidor, dependencias, m√©tricas y versiones.
    """
    try:
        # Verificar conexi√≥n con API TrackHS
        api_status = "healthy"
        api_response_time = None

        if api_client:
            try:
                start_time = time.time()
                api_client.get("pms/units/amenities", {"page": 1, "size": 1})
                api_response_time = round((time.time() - start_time) * 1000, 2)
            except Exception as e:
                api_status = "unhealthy"
                logger.warning(f"API TrackHS no disponible: {str(e)}")
        else:
            api_status = "not_configured"

        # Obtener m√©tricas del middleware
        middleware_metrics = (
            trackhs_middleware.get_metrics()
            if trackhs_middleware
            else {}
        )

        health_data = {
            "status": "healthy" if api_status in ["healthy", "not_configured"] else "degraded",
            "timestamp": datetime.now().isoformat(),
            "version": "2.0.0",
            "dependencies": {
                "trackhs_api": {
                    "status": api_status,
                    "response_time_ms": api_response_time,
                    "base_url": API_BASE_URL,
                }
            },
            "metrics": middleware_metrics,
            "environment": {
                "python_version": os.sys.version,
                "fastmcp_version": fastmcp.__version__,  # ‚úÖ Din√°mico
            },
        }

        logger.debug(f"Health check: {health_data['status']}")

        # ‚úÖ Retornar JSON string
        return json.dumps(health_data, indent=2)

    except Exception as e:
        logger.error(f"Error en health check: {str(e)}")
        error_data = {
            "status": "unhealthy",
            "timestamp": datetime.now().isoformat(),
            "error": str(e),
        }
        return json.dumps(error_data, indent=2)
```

---

## üìã Cambio 7: Usar mask_error_details con ToolError

### Archivo: `src/trackhs_mcp/server.py`

```python
from fastmcp.exceptions import ToolError

@mcp.tool(output_schema=RESERVATION_DETAIL_OUTPUT_SCHEMA)
def get_reservation(
    reservation_id: Annotated[int, Field(gt=0, ...)],
) -> Dict[str, Any]:
    """Obtener detalles completos de una reserva espec√≠fica por ID."""
    logger.info(f"Obteniendo detalles de reserva ID: {reservation_id}")

    try:
        result = api_client.get(f"pms/reservations/{reservation_id}")

        # Validar respuesta (modo no-strict)
        validated_result = validate_response(result, ReservationResponse, strict=False)

        logger.info(f"Detalles de reserva {reservation_id} obtenidos exitosamente")
        return validated_result

    except NotFoundError:
        # ‚úÖ ToolError: Este mensaje S√ç se muestra al cliente
        raise ToolError(f"Reserva {reservation_id} no encontrada en TrackHS")

    except AuthenticationError as e:
        # ‚úÖ ToolError para errores que el cliente puede resolver
        raise ToolError(f"Error de autenticaci√≥n: {str(e)}")

    except Exception as e:
        # ‚ö†Ô∏è Exception gen√©rica: se oculta con mask_error_details=True
        logger.error(f"Error obteniendo reserva {reservation_id}: {str(e)}")
        raise
```

---

## üìä Resumen de Cambios

| Cambio | Archivo | L√≠neas Eliminadas | L√≠neas Agregadas | Impacto |
|--------|---------|-------------------|------------------|---------|
| 1. Middleware nativo | `middleware.py` | ~134 | ~80 | -54 l√≠neas |
| 2. Servidor con lifespan | `server.py` | ~50 | ~80 | +30 l√≠neas |
| 3. Simplificar search_reservations | `server.py` | ~115 | ~85 | -30 l√≠neas |
| 4. Simplificar search_units | `server.py` | ~115 | ~85 | -30 l√≠neas |
| 5. Eliminar retry_with_backoff | `server.py` | ~60 | 0 | -60 l√≠neas |
| 6. Simplificar TrackHSClient | `server.py` | ~140 | ~80 | -60 l√≠neas |
| 7. Health check mejorado | `server.py` | ~52 | ~60 | +8 l√≠neas |
| 8. ToolError en tools | `server.py` | 0 | ~10 | +10 l√≠neas |
| **TOTAL** | | **~666** | **~480** | **-186 l√≠neas** |

**Mejora neta:** -186 l√≠neas (~17% reducci√≥n)

---

## üöÄ Orden de Implementaci√≥n

### Sprint 1 (1-2 horas)
1. ‚úÖ Crear nuevo `middleware.py` con `TrackHSMiddleware`
2. ‚úÖ Agregar lifespan al servidor
3. ‚úÖ Registrar middleware con `mcp.add_middleware()`
4. ‚úÖ Probar que funciona

### Sprint 2 (2-3 horas)
5. ‚úÖ Simplificar `search_reservations` (eliminar c√≥digo manual)
6. ‚úÖ Simplificar `search_units` (eliminar c√≥digo manual)
7. ‚úÖ Simplificar resto de tools
8. ‚úÖ Probar cada tool

### Sprint 3 (1-2 horas)
9. ‚úÖ Eliminar `retry_with_backoff()`
10. ‚úÖ Simplificar `TrackHSClient.get()` y `post()`
11. ‚úÖ Habilitar `mask_error_details=True`
12. ‚úÖ Agregar `ToolError` en tools

### Sprint 4 (1 hora)
13. ‚úÖ Mejorar health check
14. ‚úÖ Agregar response caching (opcional)
15. ‚úÖ Testing completo
16. ‚úÖ Actualizar documentaci√≥n

---

## ‚úÖ Checklist de Validaci√≥n

Despu√©s de cada cambio, verificar:

- [ ] ‚úÖ Servidor inicia sin errores
- [ ] ‚úÖ Tools responden correctamente
- [ ] ‚úÖ Middleware intercepta todas las llamadas
- [ ] ‚úÖ Logging funciona (sin duplicados)
- [ ] ‚úÖ Autenticaci√≥n funciona (con cache)
- [ ] ‚úÖ Reintentos funcionan en errores de red
- [ ] ‚úÖ M√©tricas se registran correctamente
- [ ] ‚úÖ Health check muestra estado correcto
- [ ] ‚úÖ Errores sensibles se ocultan con mask_error_details
- [ ] ‚úÖ Tests pasan (ejecutar suite completa)

---

## üéØ Beneficios Esperados

### C√≥digo
- ‚úÖ -17% l√≠neas de c√≥digo
- ‚úÖ -30% complejidad ciclom√°tica
- ‚úÖ Mejor separaci√≥n de responsabilidades

### Rendimiento
- ‚úÖ -40% latencia (cache de autenticaci√≥n)
- ‚úÖ Menos overhead por request
- ‚úÖ Response caching para amenidades

### Mantenibilidad
- ‚úÖ M√°s f√°cil de leer
- ‚úÖ Menos c√≥digo duplicado
- ‚úÖ Middleware centralizado

### Seguridad
- ‚úÖ Errores sensibles ocultos
- ‚úÖ Mejor logging (sin PII)
- ‚úÖ Autenticaci√≥n robusta

---

## üìö Testing Post-Refactorizaci√≥n

```bash
# 1. Tests unitarios
pytest tests/ -v

# 2. Tests de integraci√≥n
pytest tests/test_integration.py -v

# 3. Tests espec√≠ficos de middleware
pytest tests/test_middleware_integration.py -v

# 4. Test de carga (opcional)
python scripts/load_test.py

# 5. Validar health check
curl http://localhost:8000/health | jq
```

---

**Pr√≥ximo paso:** Implementar Sprint 1 üöÄ

